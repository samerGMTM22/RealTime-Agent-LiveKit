I'll help you resolve the MCP-LiveKit integration issues by searching for official patterns and best practices.Based on official LiveKit documentation and Python import best practices, here's a comprehensive solution for your MCP-LiveKit integration issues:

## Complete Solution: MCP-LiveKit Agent Integration

### Problem Analysis

Python expects a specific structure to recognize packages and modules correctly. If the package structure deviates from this standard, Python may fail to identify the parent package. Your issue occurs because:

1. When running module2.py as a script, Python doesn't recognize it as part of a package, and thus cannot find the parent package for the relative import
2. The agent runs as `python agent.py dev` making it the `__main__` module
3. Server modules use relative imports which fail when imported from a script

### Solution 1: Proper Package Structure

Create the following structure with `__init__.py` files:

```bash
/workspace/
├── agent.py                    # Main agent entry point
├── mcp_integration/           # New package for MCP code
│   ├── __init__.py           # Makes it a package
│   ├── manager.py            # MCPManager class
│   ├── client.py             # MCP client implementations
│   ├── tools.py              # LiveKit tool conversion
│   └── storage.py            # Database interface
├── server/                    # Express server (unchanged)
│   ├── mcp_routes.py         
│   └── storage.ts            
└── client/                    # React frontend (unchanged)
```

### Solution 2: Updated Agent Implementation

**agent.py** - Main entry point with proper imports:

```python
import logging
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional
from dotenv import load_dotenv

# Add the workspace root to Python path
sys.path.insert(0, str(Path(__file__).parent))

from livekit import rtc
from livekit.agents import (
    AutoSubscribe,
    JobContext,
    WorkerOptions,
    cli,
    llm,
    Agent,
    function_tool
)
from livekit.agents.multimodal import MultimodalAgent
from livekit.plugins import openai

# Now import MCP modules as a package
from mcp_integration.manager import MCPManager
from mcp_integration.tools import MCPToolsIntegration
from mcp_integration.storage import PostgreSQLStorage

load_dotenv()
logger = logging.getLogger("multimodal-agent-mcp")

class Assistant(Agent):
    def __init__(self, config: dict) -> None:
        super().__init__(
            instructions=config.get("system_prompt", "You are a helpful assistant."),
            tools=[]
        )
        self.config = config
        self.mcp_manager = None
        
    async def initialize_mcp(self, user_id: int = 1):
        """Initialize MCP servers with error handling"""
        try:
            storage = PostgreSQLStorage()
            self.mcp_manager = MCPManager(storage)
            
            # Load MCP servers for user
            mcp_servers = await self.mcp_manager.initialize_user_servers(user_id)
            
            if mcp_servers:
                # Build tools from MCP servers
                tools = await MCPToolsIntegration.build_livekit_tools(
                    self.mcp_manager.connected_servers.values()
                )
                # Update agent tools
                self.update_tools(self.tools + tools)
                logger.info(f"Loaded {len(tools)} MCP tools")
            
            return mcp_servers
            
        except Exception as e:
            logger.error(f"MCP initialization failed: {e}")
            # Agent continues without MCP tools
            return []
    
    @function_tool
    async def get_general_info(self):
        """Get general information about the system"""
        return {
            "agent_name": self.config.get("name", "Assistant"),
            "mcp_servers": len(self.mcp_manager.connected_servers) if self.mcp_manager else 0
        }

async def entrypoint(ctx: JobContext):
    """Main entry point with graceful MCP handling"""
    logger.info(f"Agent started for room: {ctx.room.name}")
    
    # Extract user ID from room metadata
    room_metadata = ctx.room.metadata or {}
    user_id = room_metadata.get("user_id", 1)
    
    # Connect to room first (always succeeds)
    await ctx.connect(auto_subscribe=AutoSubscribe.AUDIO_ONLY)
    
    # Wait for participant
    participant = await ctx.wait_for_participant()
    logger.info(f"Participant joined: {participant.identity}")
    
    # Load agent configuration
    try:
        storage = PostgreSQLStorage()
        agent_config = await storage.getAgentConfigByUserId(user_id)
        
        if not agent_config:
            # Use default configuration
            agent_config = {
                "name": "Assistant",
                "systemPrompt": "You are a helpful AI assistant.",
                "voiceModel": "coral",
                "temperature": 80
            }
    except Exception as e:
        logger.error(f"Failed to load agent config: {e}")
        agent_config = {
            "name": "Assistant",
            "systemPrompt": "You are a helpful AI assistant.",
            "voiceModel": "coral",
            "temperature": 80
        }
    
    # Create assistant
    assistant = Assistant(config=agent_config)
    
    # Initialize MCP (non-blocking)
    mcp_task = asyncio.create_task(assistant.initialize_mcp(user_id))
    
    # Initialize OpenAI Realtime model
    model = openai.realtime.RealtimeModel(
        instructions=agent_config["systemPrompt"],
        voice=agent_config.get("voiceModel", "coral"),
        temperature=(agent_config.get("temperature", 80) / 100),
        modalities=["audio", "text"],
        turn_detection=openai.realtime.TurnDetection(
            type="server_vad",
            threshold=0.5,
            prefix_padding_ms=300,
            silence_duration_ms=700
        )
    )
    
    # Create MultimodalAgent
    agent = MultimodalAgent(model=model)
    
    # Start session immediately (voice works without MCP)
    session = agent.start(ctx.room, participant)
    
    # Wait for MCP initialization (with timeout)
    try:
        mcp_servers = await asyncio.wait_for(mcp_task, timeout=5.0)
        if mcp_servers:
            logger.info(f"MCP servers loaded: {len(mcp_servers)}")
    except asyncio.TimeoutError:
        logger.warning("MCP initialization timed out, continuing without MCP tools")
    
    # Handle graceful shutdown
    @ctx.on("room_ended")
    async def on_room_ended():
        if assistant.mcp_manager:
            await assistant.mcp_manager.cleanup()

if __name__ == "__main__":
    cli.run_app(WorkerOptions(entrypoint_fnc=entrypoint))
```

### Solution 3: MCP Integration Package

**mcp_integration/__init__.py**:
```python
"""MCP Integration for LiveKit Agents"""
```

**mcp_integration/storage.py** - Database access from Python:
```python
import os
import asyncio
import asyncpg
from typing import List, Dict, Optional
from datetime import datetime

class PostgreSQLStorage:
    """Python database interface matching TypeScript storage interface"""
    
    def __init__(self):
        self.pool = None
        
    async def connect(self):
        """Create connection pool"""
        if not self.pool:
            self.pool = await asyncpg.create_pool(
                host=os.getenv("DATABASE_HOST", "localhost"),
                port=int(os.getenv("DATABASE_PORT", 5432)),
                user=os.getenv("DATABASE_USER"),
                password=os.getenv("DATABASE_PASSWORD"),
                database=os.getenv("DATABASE_NAME"),
                min_size=1,
                max_size=10
            )
    
    async def getAgentConfigByUserId(self, user_id: int) -> Optional[Dict]:
        """Get agent configuration for user"""
        await self.connect()
        
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT id, name, system_prompt, voice_model, temperature
                FROM agent_configs
                WHERE user_id = $1 AND is_active = true
                ORDER BY created_at DESC
                LIMIT 1
                """,
                user_id
            )
            
            if row:
                return {
                    "id": row["id"],
                    "name": row["name"],
                    "systemPrompt": row["system_prompt"],
                    "voiceModel": row["voice_model"],
                    "temperature": row["temperature"]
                }
            return None
    
    async def getMcpServersByUserId(self, user_id: int) -> List[Dict]:
        """Get all MCP servers for a user"""
        await self.connect()
        
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT id, name, url, description, api_key, is_active,
                       connection_status, last_connected, metadata
                FROM mcp_servers
                WHERE user_id = $1
                ORDER BY created_at DESC
                """,
                user_id
            )
            
            return [dict(row) for row in rows]
    
    async def updateMcpServer(self, server_id: int, updates: Dict) -> Optional[Dict]:
        """Update MCP server status"""
        await self.connect()
        
        # Build dynamic UPDATE query
        set_clauses = []
        values = []
        for i, (key, value) in enumerate(updates.items(), 1):
            # Convert camelCase to snake_case
            db_key = ''.join(['_'+c.lower() if c.isupper() else c for c in key]).lstrip('_')
            set_clauses.append(f"{db_key} = ${i}")
            values.append(value)
        
        values.append(server_id)
        
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                f"""
                UPDATE mcp_servers
                SET {', '.join(set_clauses)}, updated_at = NOW()
                WHERE id = ${len(values)}
                RETURNING *
                """,
                *values
            )
            
            return dict(row) if row else None
    
    async def cleanup(self):
        """Close database connections"""
        if self.pool:
            await self.pool.close()
```

**mcp_integration/manager.py**:
```python
import asyncio
import logging
from typing import Dict, List, Optional
from datetime import datetime

from .client import MCPServerHttp, MCPServerStdio
from .storage import PostgreSQLStorage

logger = logging.getLogger("mcp_manager")

class MCPManager:
    """Manages MCP server lifecycle and connections"""
    
    def __init__(self, storage: PostgreSQLStorage):
        self.storage = storage
        self.connected_servers: Dict[int, any] = {}
        self.server_capabilities: Dict[int, List[str]] = {}
        
    async def initialize_user_servers(self, user_id: int) -> List[Dict]:
        """Load and connect MCP servers for user"""
        try:
            servers = await self.storage.getMcpServersByUserId(user_id)
            active_servers = [s for s in servers if s["is_active"]]
            
            connected = []
            for server_config in active_servers:
                if await self.connect_server(server_config):
                    connected.append(server_config)
                    
            return connected
            
        except Exception as e:
            logger.error(f"Failed to initialize servers: {e}")
            return []
    
    async def connect_server(self, server_config: Dict) -> bool:
        """Connect to a single MCP server"""
        try:
            # Update status
            await self.storage.updateMcpServer(
                server_config["id"],
                {"connectionStatus": "connecting"}
            )
            
            # Create appropriate server type
            if server_config["url"].startswith("http"):
                server = MCPServerHttp(
                    name=server_config["name"],
                    url=server_config["url"],
                    api_key=server_config.get("api_key")
                )
            else:
                # Local stdio server
                server = MCPServerStdio(
                    name=server_config["name"],
                    command=server_config["url"]
                )
            
            # Connect
            if await server.connect():
                self.connected_servers[server_config["id"]] = server
                
                # Get capabilities
                tools = await server.list_tools()
                self.server_capabilities[server_config["id"]] = [
                    tool["name"] for tool in tools
                ]
                
                # Update database
                await self.storage.updateMcpServer(
                    server_config["id"],
                    {
                        "connectionStatus": "connected",
                        "lastConnected": datetime.now().isoformat(),
                        "metadata": {"capabilities": self.server_capabilities[server_config["id"]]}
                    }
                )
                
                logger.info(f"Connected to MCP server: {server_config['name']}")
                return True
                
        except Exception as e:
            logger.error(f"Failed to connect to {server_config['name']}: {e}")
            await self.storage.updateMcpServer(
                server_config["id"],
                {
                    "connectionStatus": "error",
                    "metadata": {"error": str(e)}
                }
            )
            
        return False
    
    async def cleanup(self):
        """Disconnect all servers and cleanup"""
        for server_id, server in self.connected_servers.items():
            try:
                await server.disconnect()
                await self.storage.updateMcpServer(
                    server_id,
                    {"connectionStatus": "disconnected"}
                )
            except Exception as e:
                logger.error(f"Error disconnecting server {server_id}: {e}")
        
        self.connected_servers.clear()
        await self.storage.cleanup()
```

### Solution 4: Alternative Approaches

If package restructuring is not feasible, here are alternatives:

#### Option A: Use REST API from Agent
In general, you can install any Python package or add custom code to the agent to use any database or API that you need

```python
# agent.py
import aiohttp

class MCPAPIClient:
    """Access MCP servers via Express API"""
    
    def __init__(self, base_url: str = "http://localhost:3000"):
        self.base_url = base_url
        self.session = None
        
    async def get_mcp_servers(self, user_id: int):
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{self.base_url}/api/mcp-servers/{user_id}") as resp:
                return await resp.json()
```

#### Option B: Environment-based Database Config
Use tools like .env files with python-dotenv to manage this locally

```python
# .env file
DATABASE_URL=postgresql://user:pass@localhost:5432/dbname
OPENAI_API_KEY=your-key
MCP_SERVER_URLS=http://server1,http://server2
```

### Solution 5: Graceful Degradation

If you must make a network call in the entrypoint, do so before ctx.connect(). This ensures your frontend doesn't show the agent participant before it is listening to incoming audio

The updated implementation ensures:
1. ✅ Agent starts immediately without MCP
2. ✅ Voice functionality works regardless of MCP status
3. ✅ MCP tools load asynchronously
4. ✅ Clear error messages for debugging
5. ✅ Database connection pooling for performance

### Key Takeaways

1. To ensure proper relative imports, make sure your package structure is correct. Include __init__.py files in all directories that are supposed to be packages
2. Use absolute imports when running scripts directly
3. Native support for MCP. Integrate tools provided by MCP servers with one loc - LiveKit has built-in MCP support
4. Always implement graceful degradation for external services
5. Your agent can connect to external data sources to retrieve information, store data, or take other actions

This solution follows official LiveKit patterns and Python best practices while ensuring your voice agent remains functional even when MCP integration faces issues.